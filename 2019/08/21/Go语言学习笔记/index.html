<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>Go语言学习笔记 | Wise-Bug</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Go语言学习笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Wise-Ant</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">八月 21, 2019&nbsp;&nbsp;21:16:10</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="Go-语言学习笔记"><a href="#Go-语言学习笔记" class="headerlink" title="Go 语言学习笔记"></a>Go 语言学习笔记</h1><hr>
<p><img src="/2019/08/21/Go语言学习笔记/Go's-mascot.png" alt></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里我想先介绍一下我学习 Go 语言的初衷，在 2019 秋招的时候，我接到了很多非常不错的面试机会，但由于我的计算机网络和操作系统的基础有点差（本人在校期间参加 ACM 竞赛，所以数据结构和算法并不是我的弱点），这些机会都从我的手中溜走，面经中的确有很多关于这方面的专题，但不知道为什么，总是说服不了自己去背下来（可能就是懒），在左右思量之后，决定放弃秋招，踏踏实实的补习一下这方面的知识。</p>
<p>之所以借助 Go 语言来深刻理解计算机网络和操作系统，我也是经过多方面考虑的（至于这条道路选的合不合适，我也不知道）：</p>
<ul>
<li><p>我在找工作时选的是后端方向，语言选的是 C++，但是我对C++ 某些语言特性的理解真的是惨不忍睹（甚至上升到“三观不和”地步），我分析原因：可能是对语言特性所面对的问题场景，没有什么直观的感受。这种问题场景的缺失，在学习时是很致命的，光背概念，抓不到核心问题，费时费力，性价比太低；</p>
</li>
<li><p>在面试的时候，不只一次听到大厂们（腾讯、字节、美团……）或多或少在使用 Go 语言，而且貌似培训机构对于 Go 语言的培训还不是很多，似乎有个空子（陷阱）等我去钻（掉）；</p>
</li>
<li><p>C++ 关于初学项目的太少太老太难了，Go 语言比较简单（目前来看，且侧重点也正是我所想要学习的操作系统和计算机网络的实战结合），找资料参考时应该比较方便，还有一点，也是最重要的一点，我实在搞不明白、甚至有点排斥 C++ 的内存管理机制，而且对于内存、并发等教程，网上的资料实在不敢恭维（除了针对面经所介绍的，关于具体场景的运用也很少），而 Go 语言直接在其官方文档中写的很清楚。</p>
</li>
<li><p>在这里我还要再啰嗦两句，每种语言都有其各自的特性，所针对解决的问题也各有优劣，我并不是想说 C++ 没有Go 语言好之类的言论，我真正想表达的主旨是经过各方面的考虑之后，我决定以 Go 语言作为现阶段的选择。</p>
</li>
</ul>
<h2 id="Go-语言环境配置"><a href="#Go-语言环境配置" class="headerlink" title="Go 语言环境配置"></a>Go 语言环境配置</h2><p>进入官网下载，下载 Linux 环境下的包：<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></p>
<p>例如，我下载的包为<code>go1.10.3.linux-amd64.tar.gz</code></p>
<ol>
<li><p><code>cd</code>进入你用来存放安装包的目录，然后解压到 <code>/usr/local</code>，会得到<code>go</code>文件夹：</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -C /usr/local -zxvf  go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加<code>/usr/loacl/go/bin</code>目录到PATH变量中。添加到<code>/etc/profile</code> 或<code>$HOME/.profile</code>都可以（通过<code>echo $HOME</code>可以得到具体路径）</p>
</li>
</ol>
<ol start="3">
<li><p>使用 <code>vim</code> 打开 <code>/etc/profile</code>，没有的话可以用命令<code>sudo apt-get install vim</code>安装一个</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>





</li>
</ol>
<ol start="4">
<li><p>进入之后按 <code>i</code>进入插入模式，在文件的最后插入：</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure>

<p> 按<code>Esc</code>退出插入模式，并且输入<code>：wq</code>（保存并退出）</p>
</li>
</ol>
<ol start="5">
<li><p>退出 vim 之后，输入：</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>go version</code>，如果现实版本号，则Go环境安装成功。</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ant@PC:~$ go version</span><br><span class="line">go version go1.10.3 gccgo (Ubuntu 8.3.0-6ubuntu1~18.04.1) 8.3.0 linux/amd64</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><h3 id="1-编译型语言"><a href="#1-编译型语言" class="headerlink" title="1.编译型语言"></a>1.编译型语言</h3><p>Go 使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤。</p>
<ol>
<li>使用文本编辑器创建 Go 程序；</li>
<li>保存文件；</li>
<li>编译程序；</li>
<li>运行编译得到的可执行文件。</li>
</ol>
<p>Go 自带了编译器，无须单独安装编译器。</p>
<h3 id="2-优势"><a href="#2-优势" class="headerlink" title="2.优势"></a>2.优势</h3><ul>
<li><p>Go语言在：编译速度、执行效率、开发难度，这 3 个条件之间做到了最佳的平衡。</p>
</li>
<li><p>Go语言支持交叉编译，你可以在运行 <strong>Linux</strong> 系统的计算机上开发可以在 <strong>Windows</strong> 上运行的应用程序。</p>
</li>
<li><p>Go 语言是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。</p>
</li>
<li><p>Go语言从本质上（程序和结构方面） 来实现并发编程。</p>
</li>
<li><p>Go语言没有类和继承的概念，它通过接口（interface）的概念来实现多态性。</p>
</li>
<li><p>Go语言有一个清晰易懂的轻量级类型系统， 在类型之间也没有层级之说。 因此可以说Go语言是一门混合型的语言。</p>
</li>
<li><p>Go语言的语法规则严谨，没有歧义，更没什么花里胡哨的用法。</p>
</li>
<li><p>并发模型：Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。</p>
</li>
<li><p>内存分配：Go 选择了 tcmalloc，它本就是为并发而设计的高性能内存分配组件。</p>
</li>
<li><p>垃圾回收：当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。</p>
</li>
<li><p>静态链接…</p>
</li>
<li><p>标准库：Go 标准库虽称不得完全覆盖，但也算极为丰富。</p>
</li>
<li><p>工具链：完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。</p>
</li>
</ul>
<h3 id="3-相关项目"><a href="#3-相关项目" class="headerlink" title="3.相关项目"></a>3.相关项目</h3><ul>
<li><p>Docker</p>
<p>  Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。</p>
<p>  项目链接：<a href="https://github.com/docker/docker" target="_blank" rel="noopener">https://github.com/docker/docker</a></p>
</li>
<li><h2 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h2><p>  Go语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用Go语言自身进行编写。</p>
<p>  项目链接：<a href="https://github.com/golang/go" target="_blank" rel="noopener">https://github.com/golang/go</a></p>
</li>
<li><h2 id="beego"><a href="#beego" class="headerlink" title="beego"></a>beego</h2><p>  beego 是一个类似 Python 的 Tornado 框架，采用了 RESTFul 的设计思路，使用Go语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。</p>
<p>  项目链接：<a href="https://github.com/astaxie/beego" target="_blank" rel="noopener">https://github.com/astaxie/beego</a></p>
</li>
</ul>
<h3 id="4-Go语言适合做什么"><a href="#4-Go语言适合做什么" class="headerlink" title="4.Go语言适合做什么"></a>4.Go语言适合做什么</h3><p>目前国外很多云平台都是采用Go语言开发的。</p>
<ul>
<li>服务器编程，以前大家如果使用 C 或者 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 做的那些事情，用 Go 来做也很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</li>
<li>分布式系统、数据库代理器、中间件等，例如 Etcd。</li>
<li>网络编程，这一块目前应用最广，包括 Web 应用、API 应用、下载应用，而且 Go 内置的 net/http 包基本上把我们平常用到的网络功能都实现了。</li>
<li>数据库操作</li>
<li>开发云平台，目前国外很多云平台在采用 Go 开发</li>
</ul>
<p>使用Go语言原生开发项目的出现。</p>
<ul>
<li>云计算基础设施领域，代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。</li>
<li>基础软件，代表项目：tidb、influxdb、cockroachdb 等。</li>
<li>微服务，代表项目：go-kit、micro、monzo bank 的 typhon、bilibili 等。</li>
<li>互联网基础设施，代表项目：以太坊、hyperledger 等。</li>
</ul>
<h3 id="5-Go语言四个编译阶段"><a href="#5-Go语言四个编译阶段" class="headerlink" title="5.Go语言四个编译阶段"></a>5.Go语言四个编译阶段</h3><p>Go的编译器在逻辑上可以被分成四个阶段：</p>
<ul>
<li>词法与语法分析</li>
<li>类型检查</li>
<li>中间代码生成</li>
<li>机器代码生成</li>
</ul>
<h3 id="6-Go语言工程结构"><a href="#6-Go语言工程结构" class="headerlink" title="6.Go语言工程结构"></a>6.Go语言工程结构</h3><p><strong>Go语言</strong>是一门推崇软件工程理念的编程语言，它为开发周期的每个环节都提供了完备的工具和支持。Go语言高度强调代码和项目的规范和统一，这集中体现在工程结构或者说代码体制的细节之处。接下来我们来详述Go语言的工程结构。</p>
<h4 id="1-工作区"><a href="#1-工作区" class="headerlink" title="(1) 工作区"></a>(1) 工作区</h4><p>一般情况下，Go语言的源码文件必须放在工作区中。对于命令源码文件来说，这不是必需的。</p>
<p>工作区其实就是一个对应于特定工程的目录，它应包含 3 个子目录：<strong>src 目录</strong>、<strong>pkg 目录</strong> 和 <strong>bin 目录</strong>。</p>
<h4 id="2-GOPATH"><a href="#2-GOPATH" class="headerlink" title="(2) GOPATH"></a>(2) GOPATH</h4><h4 id="3-源码文件"><a href="#3-源码文件" class="headerlink" title="(3) 源码文件"></a>(3) 源码文件</h4><h4 id="4-包的概念、导入与可见性"><a href="#4-包的概念、导入与可见性" class="headerlink" title="(4) 包的概念、导入与可见性"></a>(4) 包的概念、导入与可见性</h4><p>你必须在源文件中的第一行（非注释）来指明这个文件属于哪个包，如：<code>package main</code>。</p>
<p>所有包名都应该使用小写字母。</p>
<p><code>package main</code>表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 <code>main</code>的包。</p>
<p>一个应用程序可以包含不同的包，而且即时你只使用 <code>main</code>包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件中的第一行都使用 <code>package main</code>来指明这些文件都属于 <code>main</code> 包。</p>
<p>如果你打算编译包名不是 <code>main</code>的源文件，如<code>pack1</code>，编译后产生的对象文件将会是<code>pack1.a</code>而不是可执行程序。</p>
<h2 id="实用语法查询"><a href="#实用语法查询" class="headerlink" title="实用语法查询"></a>实用语法查询</h2><p>Go语言语法类似于C语言，C语言的有些语法会让代码可读性降低甚至发生歧义。Go语言在C语言的基础上取其精华，弃其糟粕，将C语言中较为容易发生错误的写法进行调整，做出相应的编译提示。</p>
<ul>
<li><p><strong>去掉表达式冗余括号</strong></p>
</li>
<li><p><strong>强制的代码风格</strong></p>
<p>  Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。这个特性刚开始会使开发者有一些不习惯，但随着对Go语言的不断熟悉，开发者就会发现风格统一让大家在阅读代码时把注意力集中到了解决问题上，而不是代码风格上。</p>
<p>  同时Go语言也提供了一套格式化工具。一些Go语言的开发环境或者编辑器在保存时，都会使用格式化工具对代码进行格式化，让代码提交时已经是统一格式的代码。</p>
</li>
</ul>
<h3 id="0-标准库"><a href="#0-标准库" class="headerlink" title="0.标准库"></a>0.标准库</h3><p>下表列出了Go语言标准库中常见的包及其功能。</p>
<table>
<thead>
<tr>
<th>Go语言标准库包名</th>
<th>功  能</th>
</tr>
</thead>
<tbody><tr>
<td>bufio</td>
<td>带缓冲的 I/O 操作</td>
</tr>
<tr>
<td>bytes</td>
<td>实现字节操作</td>
</tr>
<tr>
<td>container</td>
<td>封装堆、列表和环形列表等容器</td>
</tr>
<tr>
<td>crypto</td>
<td>加密算法</td>
</tr>
<tr>
<td>database</td>
<td>数据库驱动和接口</td>
</tr>
<tr>
<td>debug</td>
<td>各种调试文件格式访问及调试功能</td>
</tr>
<tr>
<td>encoding</td>
<td>常见算法如 JSON、XML、Base64 等</td>
</tr>
<tr>
<td>flag</td>
<td>命令行解析</td>
</tr>
<tr>
<td>fmt</td>
<td>格式化操作</td>
</tr>
<tr>
<td>go</td>
<td>Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改</td>
</tr>
<tr>
<td>html</td>
<td>HTML 转义及模板系统</td>
</tr>
<tr>
<td>image</td>
<td>常见图形格式的访问及生成</td>
</tr>
<tr>
<td>io</td>
<td>实现 I/O 原始访问接口及访问封装</td>
</tr>
<tr>
<td>math</td>
<td>数学库</td>
</tr>
<tr>
<td>net</td>
<td>网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等</td>
</tr>
<tr>
<td>os</td>
<td>操作系统平台不依赖平台操作封装</td>
</tr>
<tr>
<td>path</td>
<td>兼容各操作系统的路径操作实用函数</td>
</tr>
<tr>
<td>plugin</td>
<td>Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载</td>
</tr>
<tr>
<td>reflect</td>
<td>语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值</td>
</tr>
<tr>
<td>regexp</td>
<td>正则表达式封装</td>
</tr>
<tr>
<td>runtime</td>
<td>运行时接口</td>
</tr>
<tr>
<td>sort</td>
<td>排序接口</td>
</tr>
<tr>
<td>strings</td>
<td>字符串转换、解析及实用函数</td>
</tr>
<tr>
<td>time</td>
<td>时间接口</td>
</tr>
<tr>
<td>text</td>
<td>文本模板及 Token 词法器</td>
</tr>
</tbody></table>
<h3 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h3><h4 id="lt-0-gt-文件名"><a href="#lt-0-gt-文件名" class="headerlink" title="&lt;0&gt; 文件名"></a>&lt;0&gt; 文件名</h4><p>Go 的源文件以 <code>.go</code> 为后缀名存储在计算机中，这些文件名 <strong>均由小写字母</strong> 组成，如 <code>test.go</code> 。如果文件名由多个部分组成，则使用下划线 <code>_</code> 对它们进行分隔，如 <code>scanner_test.go</code> 。文件名不包含空格或其他特殊字符。</p>
<h4 id="lt-1-gt-标识符（变量名）"><a href="#lt-1-gt-标识符（变量名）" class="headerlink" title="&lt;1&gt; 标识符（变量名）"></a>&lt;1&gt; 标识符（变量名）</h4><p>有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 <code>_</code>）开头，然后紧跟着 0 个或多个字符或 Unicode 数字，如：X56、group1、_x23、i、өԑ12。</p>
<h3 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2.基本类型"></a>2.基本类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>     <span class="comment">// 布尔类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>   <span class="comment">// 字符串类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>              <span class="comment">// 整数型</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span>   <span class="keyword">float64</span>      <span class="comment">// 浮点型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">     <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span>   <span class="comment">//  复数类型</span></span><br></pre></td></tr></table></figure>

<p>Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b;</code> 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型：<code>var a, b *int</code>没有歧义。</p>
<h4 id="lt-0-gt-初始化"><a href="#lt-0-gt-初始化" class="headerlink" title="&lt;0&gt; 初始化"></a>&lt;0&gt; 初始化</h4><p>当一个变量被声明之后，所有的内存在 Go 中都是经过初始化的，系统自动赋予它该类型的零值：</p>
<ul>
<li>int 为 0</li>
<li>float 为 0.0</li>
<li>bool 为 false</li>
<li>string 为空字符串</li>
<li>指针、切片、函数变量的默认值为 <strong>nil</strong> </li>
</ul>
<h5 id="标准初始化格式"><a href="#标准初始化格式" class="headerlink" title="标准初始化格式"></a>标准初始化格式</h5><p>变量声明可以包含初始值，每个变量对应一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-1-gt-声明变量"><a href="#lt-1-gt-声明变量" class="headerlink" title="&lt;1&gt;  声明变量"></a>&lt;1&gt;  声明变量</h4><ul>
<li><p><strong>标准格式</strong>：声明变量的一般形式是使用 var 关键字：</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>  其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型，行尾无须分号。</p>
</li>
</ul>
<ul>
<li><p><strong>批量格式</strong>：使用关键字 var 和括号，可以将一组变量定义放在一起。</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">e</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>简短格式赋值：</strong>可使用更加简短的变量定义和初始化语法</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字 := 表达式</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x:=<span class="number">100</span></span><br><span class="line">   a,s:=<span class="number">1</span>, <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  需要注意的是，简短模式有以下限制：</p>
<ul>
<li>定义变量，同时显式初始化</li>
<li>不能提供数据类型</li>
<li><strong>只能用在函数内部</strong></li>
</ul>
</li>
</ul>
<h4 id="lt-2-gt-匿名变量"><a href="#lt-2-gt-匿名变量" class="headerlink" title="&lt;2&gt; 匿名变量"></a>&lt;2&gt; 匿名变量</h4><p>为了增加代码的灵活性，而产生了匿名变量。</p>
<p>匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。</p>
<p>匿名变量不占用内存空间，不会分配内存。</p>
<p>任何类型都可以赋值给它，但任何赋给这个标识符的值都将被抛弃，从某种角度上可以说，它起到了一个占位符的功能。</p>
<p>匿名变量与匿名变量之间也不会因为多次声明而无法使用。</p>
<h4 id="lt-3-gt-常量"><a href="#lt-3-gt-常量" class="headerlink" title="&lt;3&gt; 常量"></a>&lt;3&gt; 常量</h4><p>定义常量的标准语法格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure>

<p>type 可写可不写；例如可以直接写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可在全局环境中定义；</p>
<p>常量不能用 <code>：=</code>语法；</p>
<p>常量可以是字符、字符串、布尔值或数值。</p>
<h4 id="lt-4-gt-指针"><a href="#lt-4-gt-指针" class="headerlink" title="&lt;4&gt; 指针"></a>&lt;4&gt; 指针</h4><p>Go 拥有指针。指针保存了值的内存地址。</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>

<p><code>*</code> 操作符表示指针指向的底层值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure>

<p>与 C 不同，Go 没有指针运算，可以进行简单的指针操作，亲测之后，可以使用多重指针。</p>
<h4 id="lt-5-gt-结构体"><a href="#lt-5-gt-结构体" class="headerlink" title="&lt;5&gt; 结构体"></a>&lt;5&gt; 结构体</h4><p>别说话，照着这样写/用，就对了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pointer <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	position := Pointer&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	</span><br><span class="line">	pointer := &amp;position</span><br><span class="line">	</span><br><span class="line">	fmt.Println(position.X)</span><br><span class="line">	fmt.Println(pointer.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表的创建和遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span>&#123;</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">	next *node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Build_List</span><span class="params">(head *node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> father, son *node</span><br><span class="line">	father = head;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;=<span class="number">5</span> ; i++ &#123;</span><br><span class="line">		son = &amp;node&#123;val:i&#125;</span><br><span class="line">		father.next = son</span><br><span class="line">		father = son</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trav_List</span><span class="params">(head *node)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> q *node</span><br><span class="line">	q = head.next</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d "</span>, q.val)</span><br><span class="line">		q = q.next</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	head := &amp;node&#123;&#125;</span><br><span class="line">	Build_List(head)</span><br><span class="line">	Trav_List(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-6-gt-数组"><a href="#lt-6-gt-数组" class="headerlink" title="&lt;6&gt; 数组"></a>&lt;6&gt; 数组</h4><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p><strong>demo</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-7-gt-切片"><a href="#lt-7-gt-切片" class="headerlink" title="&lt;7&gt; 切片"></a>&lt;7&gt; 切片</h4><p>在这里，我要着重提一下，虽然目前为止我还没有想到切片的具体应用场景（除了可能在处理报文段时我能过觉得会用到），但我觉得还是不要给自己挖坑，仔细探讨一下切片和数组的区别。</p>
<p>切片的主要功能：通过两个下标来选择截取的范围，范围为 <strong>[low，high)</strong>，包括第一个元素，但排除最后一个元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure>

<p>对于数组，我们理论上来说只需要知道这个数组的<strong>起始地址</strong>、数据间隔、<strong>终止地址</strong> 就可以对它进行任何操作。在明白了这三个基本要素后，后面就会很好理解，切片的做法并不是直接拷贝一段数据到另一块内存区域中，而是直接使用数组的内存地址进行操作，这和引用很类似。切片会在数组的基础上根据要求自己定义<strong>起始地址</strong>和<strong>终止地址</strong>，但还会保存数组的终止地址，切片可以直接访问自己<strong>起始地址</strong>到<strong>终止地址</strong>范围的值，但在进行<strong>切片的切片</strong>时它的访问范围会扩大至切片的起始地址到数组的终止地址。</p>
<p>切片有有个基本属性：<strong>长度(len)</strong> 和 <strong>容量(cap)</strong>。</p>
<p><strong>长度</strong>的计算方式是：（切片的终止地址 - <strong>切片</strong>的起始地址）/ 数据间隔</p>
<p><strong>容量</strong>的计算方式是：（切片的终止地址 - <strong>数组</strong>的起始地址）/ 数据间隔</p>
<p>例如：一个数组 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(arr, <span class="built_in">len</span>(arr), <span class="built_in">cap</span>(arr))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[0 1 2 3 4 5 6 7 8 9]  10    10</p>
</blockquote>
<p>这个数组的长度为 10， 容量为 10；接下来我们将其进行切片；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := arr[<span class="number">2</span>:<span class="number">7</span>]</span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[2 3 4 5 6]  5   8</p>
</blockquote>
<p>该切片的长度为 5， 容量为 8；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%p -- %p\n"</span>, &amp;arr[<span class="number">2</span>], &amp;s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0xc4200143d0 – 0xc4200143d0</p>
</blockquote>
<p>但要注意 s 和 s[0] 的地址并不相同：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%p -- %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0xc420016080 – 0xc4200143d0</p>
</blockquote>
<p>使用切片进行数值更改，更改的同时底层数组中的值也会改变；</p>
<p>切片可以当做一个数组使用，但比数组要灵活很多，这个就不细说了。</p>
<p><strong>备注：切片文法</strong></p>
<p>切片文法类似于没有长度的数组文法。</p>
<p>这是一个数组文法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-8-gt-用make创建切片"><a href="#lt-8-gt-用make创建切片" class="headerlink" title="&lt;8&gt; 用make创建切片"></a>&lt;8&gt; 用make创建切片</h4><p>通过以上的了解之后，大概明白了切片确实比数组好用，但还有一个不方便之处是每次还要创建一个数组。</p>
<p>切片可以用内建函数 <code>make</code> 来创建，这也是创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)    <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure>

<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br></pre></td></tr></table></figure>

<h4 id="lt-9-gt-向切片中追加元素"><a href="#lt-9-gt-向切片中追加元素" class="headerlink" title="&lt;9&gt; 向切片中追加元素"></a>&lt;9&gt; 向切片中追加元素</h4><p>使用 <strong>append</strong> 函数可以对切片的进行元素追加。追加的元素会添加在切片的尾部，当然，这会直接改变底层数组的值，当的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组，即在底层数组够大的情况下，其引用的是底层数组（及指针是相同的），如果超出范围，会另开一个（指针用的不是同一套）。</p>
<p><strong>例如：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="keyword">int</span>&#123;<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;</span><br><span class="line">	</span><br><span class="line">	s := arr[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">	printSlice(s, arr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加一个空切片</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	printSlice(s, arr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个切片会按需增长</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">	printSlice(s, arr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	printSlice(s, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s , arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"len=%d cap=%d %v %v\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>len=1 cap=4 [9]                   [9 9 9 9 9]<br>len=2 cap=4 [9 0]                [9 9 0 9 9]<br>len=3 cap=4 [9 0 1]            [9 9 0 1 9]<br>len=6 cap=8 [9 0 1 2 3 4] [9 9 0 1 9]</p>
</blockquote>
<h4 id="lt-10-gt-映射-map"><a href="#lt-10-gt-映射-map" class="headerlink" title="&lt;10&gt; 映射 map"></a>&lt;10&gt; 映射 map</h4><p>几乎每种编程语言都存在这一种数据结构：key - value 对，通过唯一的 key 找到相对应的 value。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建:"></a>创建:</h5><p>map 的创建方式比较方便的有两种</p>
<p><strong>方法一：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">	m[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">	m[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map[one:1 two:2 three:3]</p>
</blockquote>
<p><strong>方法二：</strong>这种方法可以定义全局变量，但是必须两行都得写，有点麻烦</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">	m[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">	m[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map[two:2 three:3 one:1]</p>
</blockquote>
<p><strong>扩展：</strong>创建一个 <strong>key 为 struct</strong> 或 <strong>value 为 struct</strong> 的map。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> date <span class="keyword">struct</span> &#123;</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">	str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[date]date)</span><br><span class="line"></span><br><span class="line">	m[date&#123;<span class="number">1</span>,<span class="string">"one"</span>&#125;] = date&#123;<span class="number">100</span>, <span class="string">"Zzz..."</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map[{1 one}:{100 Zzz…}]</p>
</blockquote>
<p><strong>备注：</strong></p>
<p>map 的默认排序是随机的。</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除:"></a>删除:</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(map_name, map_key)</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">	m[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">	m[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(m, <span class="string">"one"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map[one:1 two:2 three:3]<br>map[two:2 three:3]</p>
</blockquote>
<h5 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h5><p>通过双赋值检测某个键是否存在：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>

<p>若 <code>key</code> 在 <code>m</code> 中，<code>ok</code> 为 <code>true</code> ；否则，<code>ok</code> 为 <code>false</code>。</p>
<p>若 <code>key</code> 不在映射中，那么 <code>elem</code> 是该映射元素类型的零值。</p>
<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>
<p><strong>注</strong> ：若 <code>elem</code> 或 <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok := m[key]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"one"</span>] = <span class="number">1</span></span><br><span class="line">	m[<span class="string">"two"</span>] = <span class="number">2</span></span><br><span class="line">	m[<span class="string">"three"</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	elem, ok := m[<span class="string">"one"</span>]</span><br><span class="line"></span><br><span class="line">	fmt.Println(elem, ok)</span><br><span class="line"></span><br><span class="line">	elem, ok = m[<span class="string">"four"</span>]</span><br><span class="line"></span><br><span class="line">	fmt.Println(elem, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1 true<br>0 false</p>
</blockquote>
<h4 id="lt-11-gt-列表-list"><a href="#lt-11-gt-列表-list" class="headerlink" title="&lt;11&gt; 列表 list"></a>&lt;11&gt; 列表 list</h4><p>虽然目前为止，列表在实际中几乎没用过，但我觉得还是要写一下，万一以后要查着用呢？</p>
<h5 id="引用的包："><a href="#引用的包：" class="headerlink" title="引用的包："></a>引用的包：</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br></pre></td></tr></table></figure>

<h5 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h5><p>方式1：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 := list.New()</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 list.List</span><br></pre></td></tr></table></figure>

<h5 id="添加元素："><a href="#添加元素：" class="headerlink" title="添加元素："></a>添加元素：</h5><p>所添加的元素并不要求类型一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 fist 字符串插入到列表的尾部</span></span><br><span class="line">变量名.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"><span class="comment">// 将数值 67 放入列表</span></span><br><span class="line">变量名.PushFront(<span class="number">67</span>)</span><br></pre></td></tr></table></figure>

<h5 id="删除-插入元素："><a href="#删除-插入元素：" class="headerlink" title="删除/插入元素："></a>删除/插入元素：</h5><p><strong>删除函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名.Remove(句柄)</span><br></pre></td></tr></table></figure>

<p><strong>插入函数</strong></p>
<p>往<strong>句柄之后</strong>插入元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名.InsertAfter(内容, 句柄)</span><br></pre></td></tr></table></figure>

<p>往<strong>句柄之前</strong>插入元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名.InsertBefore(内容, 句柄)</span><br></pre></td></tr></table></figure>

<p>在链表中部删除或插入某个元素时需要获取元素句柄。具体操作，请看这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部添加</span></span><br><span class="line">    l.PushBack(<span class="string">"canon"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头部添加</span></span><br><span class="line">    l.PushFront(<span class="number">67</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部添加后保存元素句柄</span></span><br><span class="line">    element := l.PushBack(<span class="string">"fist"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fist之后添加high</span></span><br><span class="line">    l.InsertAfter(<span class="string">"high"</span>, element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fist之前添加noon</span></span><br><span class="line">    l.InsertBefore(<span class="string">"noon"</span>, element)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Remove()</span></span><br><span class="line">    l.Remove(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下表中展示了每次操作后列表的实际元素情况：</strong></p>
<table>
<thead>
<tr>
<th>操作内容</th>
<th>列表元素</th>
</tr>
</thead>
<tbody><tr>
<td>l.PushBack(“canon”)</td>
<td>canon</td>
</tr>
<tr>
<td>l.PushFront(67)</td>
<td>67, canon</td>
</tr>
<tr>
<td>element := l.PushBack(“fist”)</td>
<td>67, canon, fist</td>
</tr>
<tr>
<td>l.InsertAfter(“high”, element)</td>
<td>67, canon, fist, high</td>
</tr>
<tr>
<td>l.InsertBefore(“noon”, element)</td>
<td>67, canon, noon, fist, high</td>
</tr>
<tr>
<td>l.Remove(element)</td>
<td>67, canon, noon, high</td>
</tr>
</tbody></table>
<h5 id="遍历列表："><a href="#遍历列表：" class="headerlink" title="遍历列表："></a>遍历列表：</h5><p>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := 列表名.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">    fmt.Println(i.Value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    l := list.New()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	l.PushBack(<span class="string">"one"</span>)</span><br><span class="line">	l.PushBack(<span class="string">"two"</span>)</span><br><span class="line">	l.PushBack(<span class="string">"three"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := l.Front(); i != <span class="literal">nil</span>; i = i.Next() &#123;</span><br><span class="line">		fmt.Println(i.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>one<br>two<br>three</p>
</blockquote>
<h3 id="3-常用语法"><a href="#3-常用语法" class="headerlink" title="3.常用语法"></a>3.常用语法</h3><h4 id="lt-1-gt-for-循环"><a href="#lt-1-gt-for-循环" class="headerlink" title="&lt;1&gt; for 循环"></a>&lt;1&gt; for 循环</h4><p>for 两边的括号被去掉，int 声明被简化为<code>:=</code>，直接通过编译器右值推导获得 a 的变量类型并声明。</p>
<p><strong>注意</strong>：和 C/C++  ……之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， <strong>大括号 <code>{ }</code> 则是必须的</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a := <span class="number">0</span>; a&lt;<span class="number">10</span>; a++ &#123;</span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化语句和后置语句是可选的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure>

<p>Go 语言中没有 “while” ，但可以使用以下语法代替 “while”</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br></pre></td></tr></table></figure>

<p>无限循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-2-gt-if-判断"><a href="#lt-2-gt-if-判断" class="headerlink" title="&lt;2&gt; if 判断"></a>&lt;2&gt; if 判断</h4><p>在Go语言中，表达式外无需小括号 <code>( )</code> ，而大括号 <code>{ }</code> 则是必须的。代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 &#123;</span><br><span class="line">    <span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>if</code> 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 <code>if</code> 之内。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">	  <span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if  else</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">    <span class="comment">// 表达式成立1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 表达式成立2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lt-3-gt-i-和-i"><a href="#lt-3-gt-i-和-i" class="headerlink" title="&lt;3&gt; i++ 和 ++i"></a>&lt;3&gt; i++ 和 ++i</h4><p>Go语言中自增只有一种写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure>

<p>如果写成前置自增<code>++i</code>，或者赋值后自增<code>a=i++</code>都将导致编译错误。</p>
<h4 id="lt-4-gt-函数"><a href="#lt-4-gt-函数" class="headerlink" title="&lt;4&gt; 函数"></a>&lt;4&gt; 函数</h4><h5 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="(1)基本操作"></a>(1)基本操作</h5><p>在本例中，<code>add</code> 接受两个 <code>int</code> 类型的参数。</p>
<p>注意类型在变量名 <strong>之后</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。</p>
<p>在本例中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">int</span>, y <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>被缩写为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<h5 id="2-多值返回"><a href="#2-多值返回" class="headerlink" title="(2)多值返回"></a>(2)多值返回</h5><p>函数可以返回任意数量的返回值。<code>swap</code> 函数返回了两个字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-函数值"><a href="#3-函数值" class="headerlink" title="(3)函数值"></a>(3)函数值</h5><p>在 go 语言中，函数也是值，这里指的值不是说返回值，而是可以将函数作为参数或将其整个函数作为值的意思。具体理解看样例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(func_temp <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> func_temp(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(compute(hypot))</span><br><span class="line">	fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>13<br>5<br>81</p>
</blockquote>
<p>在这个样例中，<strong>hypot</strong> 和 <strong>math.Pow</strong> 的参数类型和返回值类型都是相同的，所以可以作为 <code>compute</code>函数的参数，而且可以看出在 Go 语言中函数在创建时是可以没有名字的。</p>
<h5 id="4-函数闭包"><a href="#4-函数闭包" class="headerlink" title="(4)函数闭包"></a>(4)函数闭包</h5><p>对不起，我暂时对于函数闭包的理解还不是很清楚，主要的不是很理解名字和用法环境。</p>
<p>官方解释：</p>
<blockquote>
<p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>
</blockquote>
<p>但是我的理解是：可以实现 C++ 静态局部变量的功能</p>
<p>例子：用函数闭包实现<strong>斐波那契数列</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个“返回int的函数”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a := <span class="number">-1</span></span><br><span class="line">	b := <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		c := a + b</span><br><span class="line">		a = b</span><br><span class="line">		b = c</span><br><span class="line">		<span class="keyword">return</span> c</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := fibonacci()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(f())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0<br>1<br>1<br>2<br>3<br>5<br>8<br>13<br>21<br>34</p>
</blockquote>
<h4 id="lt-5-gt-Range"><a href="#lt-5-gt-Range" class="headerlink" title="&lt;5&gt; Range"></a>&lt;5&gt; Range</h4><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">2</span>**<span class="number">0</span> = <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">1</span> = <span class="number">2</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">2</span> = <span class="number">4</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">3</span> = <span class="number">8</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">4</span> = <span class="number">16</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">5</span> = <span class="number">32</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">6</span> = <span class="number">64</span></span><br><span class="line">&gt; <span class="number">2</span>**<span class="number">7</span> = <span class="number">128</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="lt-6-gt-switch"><a href="#lt-6-gt-switch" class="headerlink" title="&lt;6&gt; switch"></a>&lt;6&gt; switch</h4><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>
<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line">	os := runtime.GOOS</span><br><span class="line">	<span class="keyword">switch</span>  os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Go runs on Linux.</p>
</blockquote>
<h4 id="lt-7-gt-方法-amp-接口"><a href="#lt-7-gt-方法-amp-接口" class="headerlink" title="&lt;7&gt; 方法&amp;接口"></a>&lt;7&gt; 方法&amp;接口</h4><p>在 Go 语言中，也有对 Java、C++ ……中类的一些功能的替代。 在 Go 中，结构体（struct）就是用来存放数据类型，没有在其内部写个方法之类的操作，但可以实现只有某种结构体才能使用的该方法的操作，本质上和类里的方法没什么不同。</p>
<p>以下是个简单的举例，模仿着写就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    a, b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(temp node)</span> <span class="title">add</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> temp.a + temp.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Zzz := node&#123;<span class="number">5</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(Zzz.add())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>14</p>
</blockquote>
<p>接口（interface）是一种类型，一种特殊的类型。具体讲解的话略显复杂，直接看样例理解较好。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> speaker <span class="keyword">interface</span>&#123;</span><br><span class="line">	speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"miao~~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"wang~~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hit</span><span class="params">(x speaker)</span></span> &#123;</span><br><span class="line">	x.speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 cat</span><br><span class="line">	<span class="keyword">var</span> d1 dog</span><br><span class="line"></span><br><span class="line">	hit(c1)</span><br><span class="line">	hit(d1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>miao<del>~<br>wang</del></p>
</blockquote>
<p>上述代码，定义了两个结构体：cat、dog 。虽然没有什么内容，但都定义了两个属于各自结构体的方法，名字都叫 <code>speak（）</code>，现在面临的问题是，我想值用一个函数<code>hit()</code>就可以输出各自的叫声，但由于两个结构不同，且 Go 语言没有多态这个说法，所以实现不了。</p>
<p>解决上述问题就是创建一个接口（interface）类型，接口类型中包含方法的名称、参数以及返回值，但并不包含函数的具体实现。当一个结构体类型实现了某个接口中定义的所有方法后，它同时也是该接口类型的数值了。也就是说一个结构体类型既是该结构体类型也可能是一个或多个接口类型。</p>
<p>也许上述的代码例子与实际有些牵强，这里再举一个实际开发中会遇到的情况。一个开发项目中可能根据不同情况用到多种不同的数据库，但是对于增删改查这种同一类操作，我需要写n个针对不同数据库的函数接口就太过麻烦了。这里使用接口就会好很多。</p>
<p>当然，方法和接口还有很多其他的用法与细节，我在这里就不细说了，以后遇到在进行补充。</p>
<h4 id="lt-8-gt-defer"><a href="#lt-8-gt-defer" class="headerlink" title="&lt;8&gt; defer"></a>&lt;8&gt; defer</h4><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>
<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hello</p>
<p>world</p>
</blockquote>
<p><strong>defer 栈</strong></p>
<p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"counting"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"done"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>counting<br>done<br>9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>1<br>0</p>
</blockquote>
<h3 id="4-Go-并发"><a href="#4-Go-并发" class="headerlink" title="4.Go 并发"></a>4.Go 并发</h3><h4 id="1-Go程-goroutine"><a href="#1-Go程-goroutine" class="headerlink" title="1.Go程-goroutine"></a>1.Go程-goroutine</h4><p>Go 语言通过编译器运行时（runtime），从语言上支持了并发的特性。Go 语言的并发通过 <strong>goroutine</strong> 特性完成。<strong>goroutine</strong> 类似于线程，但是可以根据需要创建多个 goroutine 并发工作。goroutine 是由 Go 语言的运行时调度完成，而线程是由操作系统调度完成。</p>
<p>如果单纯的往主程序中加 Go 程的话，不一定会得到你想要得到答案，例如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(temp <span class="keyword">string</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		fmt.Println(i, <span class="string">":"</span>, temp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> say(<span class="string">"hello"</span>, <span class="number">100</span>)</span><br><span class="line">	say(<span class="string">"world"</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0 : world<br>1 : world<br>2 : world<br>3 : world<br>4 : world<br>5 : world<br>0 : hello<br>1 : hello<br>2 : hello<br>3 : hello<br>4 : hello<br>5 : hello<br>6 : hello<br>7 : hello<br>8 : hello<br>9 : hello<br>10 : hello<br>11 : hello<br>12 : hello<br>13 : hello<br>6 : world<br>7 : world<br>8 : world<br>9 : world</p>
</blockquote>
<p>如果主函数中的语句运行网络，这整个程序就会都结束，即使并行进程中的语句没有执行完也会结束。</p>
<h4 id="2-信道-channel"><a href="#2-信道-channel" class="headerlink" title="2.信道-channel"></a>2.信道-channel</h4><p>Go 语言还提供 <strong>信道 - channel</strong> 在多个 <strong>goroutine</strong> 间进行通信。</p>
<p>信道是带有类型的管道，信道在使用前必须创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>你可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v     <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">v := &lt;-ch   <span class="comment">// 从 ch 接收值并赋予 v。</span></span><br></pre></td></tr></table></figure>

<p>（“箭头”就是数据流的方向。）</p>
<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>
<p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10000</span>)</span><br><span class="line">	arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> sum(arr[:<span class="built_in">len</span>(arr)/<span class="number">2</span>], c)</span><br><span class="line">	<span class="keyword">go</span> sum(arr[<span class="built_in">len</span>(arr)/<span class="number">2</span>:], c)</span><br><span class="line"></span><br><span class="line">	x, y := &lt;-c, &lt;-c</span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0 1</p>
</blockquote>
<p>或</p>
<blockquote>
<p>1 0</p>
</blockquote>
<h4 id="3-信道的缓冲"><a href="#3-信道的缓冲" class="headerlink" title="3.信道的缓冲"></a>3.信道的缓冲</h4><p>信道可以是 <strong>带缓冲</strong> 的。将缓冲长度作为第二个参数提供给 <code>make</code> 来初始化一个带缓冲的信道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1<br>2</p>
</blockquote>
<p>对于以上的实例，可以理解为信道相当于一个有固定容量的队列，每次执行<code>&lt;-ch</code>这类操作都是弹出队首的元素。超过这个容量或队列为空的话，都会报错。</p>
<h4 id="4-range-和-close"><a href="#4-range-和-close" class="headerlink" title="4.range 和 close"></a>4.range 和 close</h4><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>

<p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p>
<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x+y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0<br>1<br>1<br>2<br>3<br>5<br>8<br>13<br>21<br>34</p>
</blockquote>
<h4 id="5-select-语句"><a href="#5-select-语句" class="headerlink" title="5.select 语句"></a>5.select 语句</h4><p><code>select</code> 语句使一个 Go 程可以等待多个通信操作。</p>
<p><code>select</code> 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch_1, ch_2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ch_1 &lt;- x:</span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;- ch_2:</span><br><span class="line">			fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">temp_func</span> <span class="params">(ch_1, ch_2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch_1)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ch_2 &lt;- <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch_1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch_2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">go</span> temp_func(ch_1, ch_2)</span><br><span class="line"></span><br><span class="line">	fibonacci(ch_1, ch_2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0<br>1<br>1<br>2<br>3<br>5<br>8<br>13<br>21<br>34<br>quit</p>
</blockquote>
<p>备注：</p>
<p>当 <code>select</code> 中的其它分支都没有准备好时，<code>default</code> 分支就会执行。</p>
<p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code> 分支：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// 使用 i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 从 c 中接收会阻塞时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-互斥锁"><a href="#6-互斥锁" class="headerlink" title="6.互斥锁"></a>6.互斥锁</h4><p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p>
<p>这里涉及的概念叫做 <em>互斥（mutual*exclusion）</em> ，我们通常使用 <em>互斥锁（Mutex）</em> 这一数据结构来提供这种机制。</p>
<p>Go 标准库中提供了 <a href="https://go-zh.org/pkg/sync/#Mutex" target="_blank" rel="noopener"><code>sync.Mutex</code></a> 互斥锁类型及其两个方法：</p>
<ul>
<li><code>Lock</code></li>
<li><code>Unlock</code></li>
</ul>
<p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p>
<p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter 的并发使用是安全的。</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">	v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">	mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc 增加给定 key 的计数器的值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Inc</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	c.mux.Lock()</span><br><span class="line">	<span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">	c.v[key]++</span><br><span class="line">	c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	c.mux.Lock()</span><br><span class="line">	<span class="comment">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class="line">	<span class="keyword">defer</span> c.mux.Unlock()</span><br><span class="line">	<span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> c.Inc(<span class="string">"somekey"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(c.Value(<span class="string">"somekey"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1000</p>
</blockquote>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Wise-Ant</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="/2019/08/21/Go语言学习笔记/">/2019/08/21/Go语言学习笔记/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/08/21/SONNIE-S-ENGE/">SONNIE'S EDGE</a>
            
            
            <a class="next" rel="next" href="/2019/08/21/C-基础技巧/">C++基础技巧</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Wise-Ant | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
