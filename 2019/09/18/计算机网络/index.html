<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>计算机网络 | Wise-Bug</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Home</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机网络</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Wise-Ant</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">九月 18, 2019&nbsp;&nbsp;13:05:33</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><hr>
<p>IP、TCP、UDP、HTTP 、HTTPS协议详解</p>
<h2 id="〇、体系结构的提出背景："><a href="#〇、体系结构的提出背景：" class="headerlink" title="〇、体系结构的提出背景："></a>〇、体系结构的提出背景：</h2><p>如果是你，<strong>你将如何实现计算机之间的信息交流</strong>呢？</p>
<p>面对这个庞大且复杂的问题，光靠一腔热血是不够的，我们必须设法将问题分解为一个个小问题，逐步实现。</p>
<p>常见的体系结构三种，但其目的都是为了解决该问题，紧抓该问题，你才能真正理解他们这样设计的原因。</p>
<h3 id="面临哪些主要问题："><a href="#面临哪些主要问题：" class="headerlink" title="面临哪些主要问题："></a>面临哪些主要问题：</h3><h4 id="1-如何发送和识别信息"><a href="#1-如何发送和识别信息" class="headerlink" title="1. 如何发送和识别信息"></a>1. 如何发送和识别信息</h4><p>首先，我们所面临的问题就是如何让计算机 <strong>发送</strong> 和 <strong>识别</strong> 0 和 1</p>
<ul>
<li>使用何种信号表示比特 0 和 1。</li>
<li>使用何种物理接口。</li>
<li>……</li>
</ul>
<h4 id="2-如何实现点对点的传播"><a href="#2-如何实现点对点的传播" class="headerlink" title="2. 如何实现点对点的传播"></a>2. 如何实现点对点的传播</h4><p>接下来我们不要急，我们需要实现一条线上的点对点的传输，不要以为点对点很稳定，这是我们经过不知道多少次的迭代才实现的。</p>
<ul>
<li>怎么实现差错检测和可靠传输。</li>
<li>怎么实现无线传输和有线传输。</li>
<li>点对点的相互接口标识。</li>
<li>……</li>
</ul>
<h4 id="3-如何扩大传播（如何利用“网”来传播）"><a href="#3-如何扩大传播（如何利用“网”来传播）" class="headerlink" title="3. 如何扩大传播（如何利用“网”来传播）"></a>3. 如何扩大传播（如何利用“网”来传播）</h4><p>经过一段时间的发展，我们意识到：不可能通过无限的添加点对点的连结来实现彼此间通信。于是乎，借助“网”来间接实现–点对点通信，成为了实现计算机网络的核心问题。</p>
<ul>
<li>怎么通过这个“网”找到“目的点”。</li>
<li>……</li>
</ul>
<h4 id="4-通信规则该如何建立"><a href="#4-通信规则该如何建立" class="headerlink" title="4. 通信规则该如何建立"></a>4. 通信规则该如何建立</h4><p>通过以上三步，通信媒介已经建立。但一组信息代表的含义该如何规定？换句话说，如何定义一种“通用语言”，能使彼此表达的信息互相理解。</p>
<p>当然，具体规则必须要更为严苛。</p>
<p>这里也可具体细化问题：</p>
<h5 id="1-计算机进程间的通信"><a href="#1-计算机进程间的通信" class="headerlink" title="(1) 计算机进程间的通信"></a>(1) 计算机进程间的通信</h5><ul>
<li>将来自网络的数据包交给哪个应用进程</li>
<li>……</li>
</ul>
<h5 id="2-相同应用间的通信规则"><a href="#2-相同应用间的通信规则" class="headerlink" title="(2) 相同应用间的通信规则"></a>(2) 相同应用间的通信规则</h5><ul>
<li>……</li>
</ul>
<h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><p>这里已经将进行计算机相互通信所面临的基本问题都提出来了，各种体系结构也是针对这些问题所提出的解决方案。只是它们在实际过程中，将某些问题合并或者继续拆分了。</p>
<p>如果用一句话来解释 TCP、IP、HTTP 协议：</p>
<ul>
<li>TCP 协议保证传输的数据准确无误</li>
<li>IP 协议保证能找到是哪台机器</li>
<li>HTTP 协议表示传递的数据是什么格式</li>
</ul>
<h2 id="一、什么是协议"><a href="#一、什么是协议" class="headerlink" title="一、什么是协议"></a>一、什么是协议</h2><p>协议是一种约定，是一种人为设计的规则。之所以需要创造这些协议，不是计算机设备传播不了信息，是因为我们需要一种约定俗成的话语体系来规范彼此交流格式。</p>
<p>如果你明白了上面的意思，也就明白了 <strong>IP、TCP、UDP、HTTP 等协议</strong> 所解决问题的重点在于使计算机交流<strong>更加便捷</strong>。以此作为学习它们的背景，你会更加容易理解。</p>
<h2 id="二、TCP-IP-协议簇"><a href="#二、TCP-IP-协议簇" class="headerlink" title="二、TCP/IP 协议簇"></a>二、TCP/IP 协议簇</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>互联网早期时，尽管已经实现了计算机的彼此连接，但是因为没有协议，基本没有办法进行大规模的数据通信。当然，当时的人也意识到了这个问题，衍生了很多为了解决这个问题的协议。像 HTTP 协议就是为了约定传输文本时的一种协议……</p>
<p>而 TCP/IP 协议并不是指某一个具体的协议，它是指代一系列的协议栈，因此也叫 <strong>TCP/IP 协议栈</strong> 或者 <strong>TCP/IP 协议簇</strong> 。</p>
<h3 id="2-TCP-IP-体系结构"><a href="#2-TCP-IP-体系结构" class="headerlink" title="2. TCP/IP 体系结构"></a>2. TCP/IP 体系结构</h3><ul>
<li>广义上来说，<strong>TCP/IP</strong> 指的是4层的总和。</li>
<li>狭义上来说，指的是 <strong>传输层</strong> 和 <strong>网络互联层</strong> 。</li>
</ul>
<p><img src="/2019/09/18/计算机网络/OSI%E5%92%8CTCP.png" alt="OSI和TCP"></p>
<p>在 <strong>TCP/IP 协议簇</strong> 中，定义了包含对应 OSI 模型的每一层。但同时对 OSI 模型层做了简化处理。即OSI模型中的 7 层，在 TCP/IP 中使用 4 层代替。</p>
<h3 id="3-TCP-IP-协议簇的构成"><a href="#3-TCP-IP-协议簇的构成" class="headerlink" title="3. TCP/IP 协议簇的构成"></a>3. TCP/IP 协议簇的构成</h3><p><strong>TCP/IP 协议簇</strong> 中每一层都对应的协议，最终组成 <strong>协议簇</strong>。 </p>
<p><img src="/2019/09/18/计算机网络/TCP%E5%85%B7%E4%BD%93%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE.png" alt></p>
<p><strong>TCP/IP 协议簇</strong> 中每一层都对应的协议，最终组成 <strong>协议簇</strong>。 </p>
<h3 id="4-数据封包发送流程"><a href="#4-数据封包发送流程" class="headerlink" title="4. 数据封包发送流程"></a>4. 数据封包发送流程</h3><p>这里借用 5 层体系结构来进行说明，融合了 OSI  与 TCP/IP 的体系结构。TCP/IP 协议主要考察的重点在于也是在 <strong>应用层</strong>、<strong>传输层</strong>、<strong>网络互联层</strong> 的协议，从下图也可以看出，对于这三层是结合 TCP/IP 协议里的内容的。</p>
<h4 id="（1）五层体系结构"><a href="#（1）五层体系结构" class="headerlink" title="（1）五层体系结构"></a>（1）五层体系结构</h4><table>
<thead>
<tr>
<th align="center">层级</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">应用层</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">运输层</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">网络层</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">数据链路层</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">物理层</td>
</tr>
</tbody></table>
<h4 id="（2）数据封包发送流程动图"><a href="#（2）数据封包发送流程动图" class="headerlink" title="（2）数据封包发送流程动图"></a>（2）数据封包发送流程动图</h4><p><img src="/2019/09/18/计算机网络/0.gif" alt></p>
<h4 id="（3）每层的具体情况"><a href="#（3）每层的具体情况" class="headerlink" title="（3）每层的具体情况"></a>（3）每层的具体情况</h4><p><img src="/2019/09/18/计算机网络/8.png" alt></p>
<h2 id="三、应用层"><a href="#三、应用层" class="headerlink" title="三、应用层"></a>三、应用层</h2><h3 id="1-HTTP-协议"><a href="#1-HTTP-协议" class="headerlink" title="1. HTTP 协议"></a>1. HTTP 协议</h3><p>HTTP 协议名为超文本传输协议。这个协议在 TCP/IP 协议栈的应用层，因此我们无需操心 HTTP 是如何传输的，只需要关心传输的内容/格式，能否正确的被接收端识别。</p>
<p>HTTP 是基于 TCP 实现的，简单的来说，TCP 协议负责可靠的内容传输，HTTP 协议负责传输的内容部分。两者本身不再一个层面，没有可比性。</p>
<p>HTTP 无状态的意思是，每一次的内容每一次的内容解析是没有关联的。</p>
<p>HTTP 包含两种报文类型：<strong>请求报文</strong>、<strong>响应报文</strong>。请求报文用在客户端对服务器的请求时使用的报文格式，响应用在服务器响应请求的报文格式。</p>
<h4 id="（1）HTTP-请求结构"><a href="#（1）HTTP-请求结构" class="headerlink" title="（1）HTTP 请求结构"></a>（1）HTTP 请求结构</h4><p>HTTP 的请求分为：请求行、请求头、请求体（请求数据）。</p>
<p><img src="/2019/09/18/计算机网络/HTTP%E8%AF%B7%E6%B1%82.png" alt></p>
<p><img src="/2019/09/18/计算机网络/HTTP%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BE%8B.png" alt></p>
<h4 id="（2）HTTP-请求行"><a href="#（2）HTTP-请求行" class="headerlink" title="（2）HTTP 请求行"></a>（2）HTTP 请求行</h4><p><strong>请求方法：</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">实体中包含一个表，表中说明与该URI所表示的原内容的区别。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">MOVE</td>
<td align="left">请求服务器将指定的页面移至另一个网络地址。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">COPY</td>
<td align="left">请求服务器将指定的页面拷贝至另一个网络地址。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">LINK</td>
<td align="left">请求服务器建立链接关系。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">UNLINK</td>
<td align="left">断开链接关系。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">WRAPPED</td>
<td align="left">允许客户端发送经过封装的请求。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">Extension-mothed</td>
<td align="left">在不改动协议的前提下，可增加另外的方法。</td>
</tr>
</tbody></table>
<p><strong>URL—统一资源定位符</strong></p>
<p>这里觉得有必要说一下 URL（统一资源定位符）、 URI（统一资源标识符） 、URN（统一资源名称）的区别。</p>
<p><img src="/2019/09/18/计算机网络/URL%E3%80%81URI%E3%80%81URN%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt></p>
<p>URL的一般语法格式为：（带 [ ] 的为可选项）</p>
<p><code>protocol://hostname[:port]/path/[;parameters][?query]#fragment</code></p>
<ul>
<li><p>protocol : 协议，下面列举一些常见的协议</p>
<ul>
<li>file : 资源是本地计算机上的文件。格式file:///，注意后边应是三个斜杠。</li>
<li>ftp : 通过 FTP访问资源。格式 FTP:// </li>
<li>http : 通过 HTTP 访问该资源，最常用的协议。 格式 http://</li>
<li>https : 通过安全的 HTTPS 访问该资源。 格式 https://</li>
<li>mailto : 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:</li>
<li>MMS : 通过支持 MMS（流媒体）协议的播放该资源。（代表软件：Windows Media Player）格式 MMS://</li>
<li>ed2k : 通过 支持ed2k（专用下载链接）协议的P2P软件访问该资源。（代表软件：电驴） 格式 ed2k://</li>
<li>Flashget 通过 支持Flashget:（专用下载链接）协议的P2P软件访问该资源。（代表软件：快车） 格式 Flashget://</li>
<li>thunder 通过 支持thunder（专用下载链接）协议的P2P软件访问该资源。（代表软件：迅雷） 格式 thunder://</li>
<li>news 通过 NNTP 访问该资源。</li>
<li>gopher : 通过 Gopher 协议访问该资源。</li>
</ul>
</li>
<li><p>hostname : 主机名</p>
</li>
<li><p>port : 端口号，整数，可选</p>
</li>
<li><p>path : 路径，由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。</p>
</li>
<li><p>parameters : 参数，这里用于指定特殊参数的可选项。</p>
</li>
<li><p>query ：查询，可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。</p>
</li>
<li><p>fragment : 信息片段，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使 fragment直接定位到某一名词解释。</p>
</li>
</ul>
<p>URL 样例讲解（部分）：</p>
<p><img src="/2019/09/18/计算机网络/URL%E6%A0%B7%E4%BE%8B%E4%BB%8B%E7%BB%8D.png" alt></p>
<h4 id="（3）HTTP-请求头"><a href="#（3）HTTP-请求头" class="headerlink" title="（3）HTTP 请求头"></a>（3）HTTP 请求头</h4><p>请求头中主要包含本次请求的附加信息，其参数所代表的信息如下：</p>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">解释</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">指定客户端能够接收的内容类型</td>
<td align="left">Accept: text/plain, text/html</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">浏览器可以接受的字符编码集。</td>
<td align="left">Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td align="left">Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">浏览器可接受的语言</td>
<td align="left">Accept-Language: en,zh</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">可以请求网页实体的一个或者多个子范围字段</td>
<td align="left">Accept-Ranges: bytes</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">HTTP授权的授权证书</td>
<td align="left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
<td align="left">Cache-Control: no-cache</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td align="left">Connection: close</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td align="left">Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">请求的内容长度</td>
<td align="left">Content-Length: 348</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">请求的与实体对应的MIME信息</td>
<td align="left">Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">请求发送的日期和时间</td>
<td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td align="left">Expect</td>
<td align="left">请求的特定的服务器行为</td>
<td align="left">Expect: 100-continue</td>
</tr>
<tr>
<td align="left">From</td>
<td align="left">发出请求的用户的Email</td>
<td align="left">From: <a href="mailto:user@email.com" target="_blank" rel="noopener">user@email.com</a></td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">指定请求的服务器的域名和端口号</td>
<td align="left">Host: <a href="http://www.zcmhi.com" target="_blank" rel="noopener">www.zcmhi.com</a></td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">只有请求内容与实体相匹配才有效</td>
<td align="left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td align="left">If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td align="left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td align="left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">只在实体在指定时间之后未被修改才请求成功</td>
<td align="left">If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td align="left">Max-Forwards</td>
<td align="left">限制信息通过代理和网关传送的时间</td>
<td align="left">Max-Forwards: 10</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">用来包含实现特定的指令</td>
<td align="left">Pragma: no-cache</td>
</tr>
<tr>
<td align="left">Proxy-Authorization</td>
<td align="left">连接到代理的授权证书</td>
<td align="left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">只请求实体的一部分，指定范围</td>
<td align="left">Range: bytes=500-999</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">先前网页的地址，当前请求网页紧随其后,即来路</td>
<td align="left">Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td align="left">TE</td>
<td align="left">客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td align="left">TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">User-Agent的内容包含发出请求的用户信息</td>
<td align="left">User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">通知中间网关或代理服务器地址，通信协议</td>
<td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">关于消息实体的警告信息</td>
<td align="left">Warn: 199 Miscellaneous warning</td>
</tr>
</tbody></table>
<p>Content-Type：  请求的与实体对应的MIME信息，常用的类型如下：</p>
<ul>
<li>text/html：HTML格式</li>
<li>text/plain：纯文本格式</li>
<li>text/xml：XML格式</li>
<li>image/gif：gif图片格式</li>
<li>image/jpeg：jpg图片格式</li>
<li>image/png：png图片格式</li>
<li>application/xhtml+xml：XHTML格式</li>
<li>application/xml：XML数据格式</li>
<li>application/atom+xml：Atom XML聚合格式</li>
<li>application/json：JSON数据格式</li>
<li>application/pdf：pdf 格式</li>
<li>application/msword：Word 文档格式</li>
<li>application/octet-stream：二进制数据流（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded：<code>&lt;form encType=&quot;&quot;&gt;</code> 中默认的 encType， form 表单数据被编码为到服务器（表单默认的提交数据格式）</li>
</ul>
<h4 id="（4）HTTP-请求体"><a href="#（4）HTTP-请求体" class="headerlink" title="（4）HTTP 请求体"></a>（4）HTTP 请求体</h4><p><img src="/2019/09/18/计算机网络/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5CHTTP%E8%AF%B7%E6%B1%82%E5%AE%9E%E4%BE%8B.png" alt></p>
<p>在整个报文中，请求头（报文头）之后，隔一行空格，以下部分就是HTTP的请求体（报文体）了。</p>
<p>请求体是我们发送请求的时候需要传给接收端的内容。</p>
<p>其格式需要和请求头中的<strong>Content-Type</strong>对应。不然会导致接受无法识别。</p>
<p>如上图中的请求体： <code>name=tom&amp;password=123&amp;realName=tomson</code></p>
<h4 id="（5）HTTP-响应结构"><a href="#（5）HTTP-响应结构" class="headerlink" title="（5）HTTP 响应结构"></a>（5）HTTP 响应结构</h4><p>HTTP 的响应同样分为：响应行、响应头、响应体。</p>
<p>总体结构如图：</p>
<p><img src="/2019/09/18/计算机网络/HTTP%E5%93%8D%E5%BA%94.png" alt></p>
<h4 id="（6）HTTP-响应行"><a href="#（6）HTTP-响应行" class="headerlink" title="（6）HTTP 响应行"></a>（6）HTTP 响应行</h4><p>响应行中包含了 HTTP 的版本和本次请求的状态码。HTTP 状态码的分类如下：</p>
<p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP 状态码共分为 5 种类型：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">指示信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，信息不完整，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>HTTP 状态码列表</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td align="left">102</td>
<td align="left">由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td align="left">207</td>
<td align="left">由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td align="left">421</td>
<td align="left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td align="left">422</td>
<td align="left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td align="left">422</td>
<td align="left">请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td align="left">424</td>
<td align="left">由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td align="left">425</td>
<td align="left">在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td align="left">426</td>
<td align="left">客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td align="left">449</td>
<td align="left">由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td align="left">506</td>
<td align="left">由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td align="left">507</td>
<td align="left">服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td align="left">509</td>
<td align="left">服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td align="left">510</td>
<td align="left">获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody></table>
<h4 id="（7）HTTP-响应头"><a href="#（7）HTTP-响应头" class="headerlink" title="（7）HTTP 响应头"></a>（7）HTTP 响应头</h4><p>响应头用于描述服务器的基本信息、数据的格式，这些信息将告知客户端如何处理响应中的内容。</p>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">解释</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept-Ranges</td>
<td align="left">表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td align="left">Accept-Ranges: bytes</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td align="left">Age: 12</td>
</tr>
<tr>
<td align="left">Allow</td>
<td align="left">对某网络资源的有效的请求行为，不允许则返回405</td>
<td align="left">Allow: GET, HEAD</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td align="left">Cache-Control: no-cache</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">web服务器支持的返回内容压缩编码类型。</td>
<td align="left">Content-Encoding: gzip</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">响应体的语言</td>
<td align="left">Content-Language: en,zh</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">响应体的长度</td>
<td align="left">Content-Length: 348</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">请求资源可替代的备用的另一地址</td>
<td align="left">Content-Location: /index.htm</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">返回资源的MD5校验值</td>
<td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">在整个返回体中本部分的字节位置</td>
<td align="left">Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">返回内容的MIME类型</td>
<td align="left">Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">原始服务器消息发出的时间</td>
<td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">请求变量的实体标签的当前值</td>
<td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">响应过期的日期和时间</td>
<td align="left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">请求资源的最后修改时间</td>
<td align="left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td align="left">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td align="left">Pragma: no-cache</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">它指出认证方案和可应用到代理的该URL上的参数</td>
<td align="left">Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td align="left">refresh</td>
<td align="left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td align="left">Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td align="left">Retry-After: 120</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">web服务器软件名称</td>
<td align="left">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置Http Cookie</td>
<td align="left">Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left">指出头域在分块传输编码的尾部存在</td>
<td align="left">Trailer: Max-Forwards</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">文件传输编码</td>
<td align="left">Transfer-Encoding:chunked</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td align="left">Vary: *</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">告知代理客户端响应是通过哪里发送的</td>
<td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">警告实体可能存在的问题</td>
<td align="left">Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">表明客户端请求实体应该使用的授权方案</td>
<td align="left">WWW-Authenticate: Basic</td>
</tr>
</tbody></table>
<h4 id="（8）HTTP-响应体"><a href="#（8）HTTP-响应体" class="headerlink" title="（8）HTTP 响应体"></a>（8）HTTP 响应体</h4><p>响应体就是响应的消息体，如果是纯数据就返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS类就是JS代码，诸如此类</p>
<h4 id="（9）通用头"><a href="#（9）通用头" class="headerlink" title="（9）通用头"></a>（9）通用头</h4><h2 id="四、传输层"><a href="#四、传输层" class="headerlink" title="四、传输层"></a>四、传输层</h2><p>传输层的主要作用是分割应用层的数据，并把数据包传给IP层。</p>
<p>常用的应用程序及对应的传输层协议：</p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TFTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>HTTP</th>
<th>SSH</th>
<th>MYSQL</th>
</tr>
</thead>
<tbody><tr>
<td>端口号</td>
<td>21,20</td>
<td>69</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>80</td>
<td>22</td>
<td>3306</td>
</tr>
<tr>
<td>传输层协议</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>UDP</td>
<td>TCP</td>
<td>TCP</td>
<td>TCP</td>
</tr>
</tbody></table>
<h3 id="1-TCP协议"><a href="#1-TCP协议" class="headerlink" title="1. TCP协议"></a>1. TCP协议</h3><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="(1) 简介"></a>(1) 简介</h4><p>TCP 协议位于协议栈的传输层。当应用层向 TCP 层发送用于网间传输的数据流时，TCP则把数据量分割成适当的长度的报文段，最大传输段的大小（MSS）通常受该计算机网络中数据链路层的最大传输单元（MTU）的限制。之后，TCP把数据包传给IP层，由它来通过网络将包传给接收端的TCP层。</p>
<p>TCP为了保证报文传输的可靠性，就给每个包一个序列，同时序号也保证了传送到接受端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返实体在合理的往返时延（RTT）内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<p>TCP 是面向连接的协议，因此每个 TCP 连接都有 3 个阶段：连接建立、数据传输、连接释放。</p>
<h4 id="2-核心内容"><a href="#2-核心内容" class="headerlink" title="(2) 核心内容"></a>(2) 核心内容</h4><ul>
<li><p>为了保证数据的正确性/合法性，TCP 用一个校验函数来验证数据是否存在错误，在发送和接受时都要进行计算；同时可以使用 md5 技术对数据进行认证加密。</p>
</li>
<li><p>为了保证数据的可靠性，采用超时重传和捎带确认机制。</p>
</li>
<li><p>在流量控制上，采用滑动窗口协议（连续ARQ协议）实现，协议中规定，对于窗口内未经确认的分组需要重传。（流量控制就是让发送方的发送速率不要太快，要让接收方来得及接受，<strong>根本目的是为了避免分组丢失</strong>，它是构成TCP可靠性的一方面）</p>
</li>
<li><p>在拥塞控制上，采用TCP拥塞控制算法（AIMD算法），该算法主要包括三个主要部分：（1）加性增、乘性减；（2）慢启动；（3）对超时事件做出反应。</p>
<p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免网络负载过大的情况。常用的方法就是：（1）慢开始、拥塞避免；（2）快重传、快恢复。</p>
</li>
<li><p>当然，这里只是大致的说了一下，具体细节部分还有很多没说。</p>
</li>
</ul>
<h4 id="3-TCP-报文段格式"><a href="#3-TCP-报文段格式" class="headerlink" title="(3) TCP 报文段格式"></a>(3) TCP 报文段格式</h4><p><img src="/2019/09/18/计算机网络/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E6%A0%BC%E5%BC%8F.png" alt></p>
<h5 id="lt-1-gt-端口号"><a href="#lt-1-gt-端口号" class="headerlink" title="&lt;1&gt; 端口号"></a>&lt;1&gt; <strong>端口号</strong></h5><p>​    用来标识同一台计算机的不同进程</p>
<ul>
<li><strong>源端口（Source Port）</strong>：占2个字节，源端口和IP得知的作用是标识报文的返回地址</li>
<li><strong>目的端口（Destination Port）</strong>：占2个字节，端口指明接受方计算机上的应用程序接口</li>
</ul>
<p>TCP 报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p>
<h5 id="lt-2-gt-序列号和确认号"><a href="#lt-2-gt-序列号和确认号" class="headerlink" title="&lt;2&gt; 序列号和确认号"></a>&lt;2&gt; <strong>序列号和确认号</strong></h5><p>他们是TCP可靠传输的关键部分。TCP 是面向字节流的，对于一个需要发送的文件，我们需要将文件的字节流进行编号，例如我们有一个1000字节的文件，其编号范围就是 0~999 。</p>
<p><strong>序列号（Sequece Number）</strong>：占4个字节。序号范围为 2^32（42亿个左右）。序号增加到 2^32 -1 后，下一个序号就又回到了 0。也就是说，序号使用 mod 2^32 运算。<strong>序列号是本次发送数据的第一个字节的序列号</strong>。例如，一段报文的序列号字段是 301， 而携带的数据共有 100 字段，显然下一个报文段（如果还有的话）的数据序列号为 401 。</p>
<p><strong>确认号（Acknowledgement Number）</strong>：占4个字节。包含两个信息：若确认号为 N，<strong>表示期望收到的下一个序号</strong>；<strong>到序列号 N-1 为止的所有数据都已经正确收到</strong>。还有一点必须要明确，序列号 和 确认号 所描述的数据对象并不是同一个，这点在刚开始学习的过程中有点模糊。</p>
<h5 id="lt-3-gt-TCP-首部长度"><a href="#lt-3-gt-TCP-首部长度" class="headerlink" title="&lt;3&gt; TCP 首部长度"></a>&lt;3&gt; <strong>TCP 首部长度</strong></h5><p>英文：Offset，它也叫数据偏移，由于TCP 首部包含一个长度可变的“选项”部分，所以需要这么一个值来指定这个TCP报文段到底有多长。</p>
<p>占 4 bits，0~15。如果 TCP 首部长度为 N，则代表该 TCP首部有 N 字节大小。由于存在“选项”部分，TCP报头的大小是不确定的，最小20字节，最大60字节（15*32/8=60）。</p>
<h5 id="lt-4-gt-保留"><a href="#lt-4-gt-保留" class="headerlink" title="&lt;4&gt; 保留"></a>&lt;4&gt; <strong>保留</strong></h5><p>英文：Reserved，占 0.75 字节（6 bits）。保留为今后使用，但目前应置为 0 。</p>
<h5 id="lt-5-gt-标志位"><a href="#lt-5-gt-标志位" class="headerlink" title="&lt;5&gt;标志位"></a>&lt;5&gt;<strong>标志位</strong></h5><p>英文：TCP Flags，主要用于标志该报文当前的状态，只有 0 和 1 两种状态，常见的有 6 个。</p>
<ul>
<li><p><strong>SYN</strong>：建立连接时使用，用来同步序列号。</p>
<p>TCP 规定，SYN 报文段（SYN = 1 的报文段）不能携带数据，但需要消耗一个序列号。</p>
<p>当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；</p>
<p>当 SYN=1，ACK=1 时，表示对方同意建立连接。</p>
<p>SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在两次握手中 SYN 才会置为 1。</p>
</li>
<li><p><strong>ACK</strong>：表示前面的确认号是否有效。ACK=1 ，表示有效。只有当 ACK=1时，前面的确认号字段才有效。TCP规定，协议建立连接后，ACK必须位1。</p>
</li>
<li><p><strong>FIN</strong>：标记数据是否发送完毕。TCP 规定， FIN 报文段即使不携带数据（可以带数据），也要消耗一个序号。</p>
</li>
</ul>
<ul>
<li><strong>URG</strong>：表示该报文中是否包含紧急数据，相当于优先级高的数据。URG=1，表示有紧急数据。后面的紧急指针字段只有当 URG=1 时才有效。</li>
<li><strong>PSH</strong>：告诉对方收到该报文数据之后，是否应该把数据推送给应用进程。如果为1，则表示对方应当立即把数据提交给应用进程，而不是缓存起来。</li>
<li><strong>RST</strong>：只有当 RST =1 时才有用。如果你收到一个 RST=1 的报文，说明你与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。或者说你上次发送给主机的数据有问题，主机拒绝响应。</li>
</ul>
<h5 id="lt-6-gt-窗口大小"><a href="#lt-6-gt-窗口大小" class="headerlink" title="&lt;6&gt; 窗口大小"></a>&lt;6&gt; <strong>窗口大小</strong></h5><p>英文：Window，占2字节。“窗口大小”字段通常用于告知对方自己能够接受数据量的大小。窗口的本质就是一个缓冲区 buffer，该字段的值用于告知对方自己剩余的可用缓冲区大小。在每一个TCP报文段中都会通过“窗口”字段告知对方自己所能接受数据的大小。窗口大小通常用于流量控制。</p>
<p>   例如：我发送一个报文段，其确认号是701，窗口字段是 1000。这就是要告诉对方：“从701算起，我（即发送方报文段的一方）的接受缓存空间还可接受 1000 字节数据，你在给我发数据时，必须考虑到这一点。</p>
<p>   总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。</p>
<h5 id="lt-7-gt-校验和"><a href="#lt-7-gt-校验和" class="headerlink" title="&lt;7&gt; 校验和"></a>&lt;7&gt; <strong>校验和</strong></h5><p>英文：Checksum，占2字节。奇偶校验，此校验和是对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>
<h5 id="lt-8-gt-紧急指针"><a href="#lt-8-gt-紧急指针" class="headerlink" title="&lt;8&gt; 紧急指针"></a>&lt;8&gt; <strong>紧急指针</strong></h5><p>英文：Urgent Pointer，占2字节。紧急指针仅在 <code>URG=1</code>时才有意义，它指出本报文段中的紧急数据的字节数。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<h5 id="lt-9-gt-选项"><a href="#lt-9-gt-选项" class="headerlink" title="&lt;9&gt; 选项"></a>&lt;9&gt; 选项</h5><p>英文：TCP Options，长度可变，最长可达40字节。当没有使用“选项”时，TCP 的首部长度是 20字节。</p>
<h4 id="4-三次握手"><a href="#4-三次握手" class="headerlink" title="(4) 三次握手"></a>(4) 三次握手</h4><p>连接建立经历三个步骤（发送三次报文段），通常成为“三次握手”。</p>
<p><img src="/2019/09/18/计算机网络/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt></p>
<p><img src="/2019/09/18/计算机网络/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt></p>
<ol start="0">
<li><p><strong>准备阶段</strong></p>
<p> 当客户端和服务端把各自的 socket<a href="socket：套接字，准备时包含两个成分，一个是IP地址，一个是端口。">^注释2</a> 和 TCB<a href="TCB：在同一时刻，设备可能会产生多种数据句需要分发给不同的设备，为了确保数据能够正确分发，TCP用一种叫做TCB的传输控制模块的数据结构，把发给不同设备的数据封装起来，我们可以把结构看做是信封。">^注释1</a> 传输控制模块准备好后，双方就可以进入“三次握手”了。</p>
</li>
</ol>
<ol>
<li><p><strong>第一次握手</strong></p>
<p>  客户端发送一个 SYN 报文给服务器，报文中包含了客户端到服务器端的初始序列号。</p>
</li>
</ol>
<ol>
<li><strong>第二次握手</strong><br> 服务器收到报文之后，回发一个SYN + ACK 的报文，报文中包含了服务器到客户端的初始序列号和确认号。</li>
</ol>
<ol start="3">
<li><strong>第三次握手</strong><br>客户端收到报文之后，回发一个ACK报文，当然还包括序列号和确认号，整个连接流程完毕。</li>
</ol>
<ol start="4">
<li><strong>数据传输</strong></li>
</ol>
<h4 id="5-四次挥手"><a href="#5-四次挥手" class="headerlink" title="(5) 四次挥手"></a>(5) 四次挥手</h4><p><img src="/2019/09/18/计算机网络/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.gif" alt></p>
<p><img src="/2019/09/18/计算机网络/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt></p>
<ol start="0">
<li><strong>数据传输</strong></li>
</ol>
<ol>
<li><p><strong>第一次挥手</strong>：</p>
<p>客户端向服务器发送 FIN + ACK 报文，报文中包括序号 u 。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>第二次挥手:</strong></p>
<p>服务器收到后回复一份 ACK 报文，报文中包含序号 v，确认号 u+1。但由于服务器可能还在处理事物，因此，报文并不会携带 FIN 标识符。</p>
</li>
</ol>
<ol start="3">
<li><p><strong>第三次挥手：</strong></p>
<p> 在一段时间之后，服务器已经处理完毕，发送 FIN + ACK 的报文，报文中序号为 w，确认号为 u+1。</p>
</li>
</ol>
<ol start="4">
<li><p><strong>第四次挥手：</strong></p>
<p> 客户端发送 ACK 报文，序号为 u+1， 确认号为 w+1。</p>
</li>
</ol>
<ol start="5">
<li><strong>CLOSED</strong></li>
</ol>
<h2 id="五、网络互联层-不完整，有空总结"><a href="#五、网络互联层-不完整，有空总结" class="headerlink" title="五、网络互联层(不完整，有空总结)"></a>五、网络互联层(不完整，有空总结)</h2><h3 id="1-IP-协议"><a href="#1-IP-协议" class="headerlink" title="1. IP 协议"></a>1. IP 协议</h3><p>对于这部分，我想先提一个问题：</p>
<ul>
<li>为什么使用 <a href="https://httpbin.org/get" target="_blank" rel="noopener">httpbin.org/get</a> 反馈得到的 IP 地址 和 使用 ifconfig（查询本机IP地址的命令）查询的到的 IP 地址不同呢？</li>
</ul>
<p><img src="/2019/09/18/计算机网络/%E7%BD%91%E7%BB%9Cip%E5%9C%B0%E5%9D%80.png" alt></p>
<p><img src="/2019/09/18/计算机网络/%E6%9C%AC%E5%9C%B0ip%E5%9C%B0%E5%9D%80.png" alt></p>
<p>使用 <a href="https://httpbin.org/get" target="_blank" rel="noopener">httpbin.org/get</a>  访问得到的 IP 为公有 IP 地址， 使用 ifconfig 得到的 IP 为私有 IP 地址。</p>
<p>因为世界上所有的 IP 地址 加起来一共也就 42亿个左右，每个设备分配一个IP地址肯定是不够用的。</p>
<p>于是乎有人产生了一个大胆的想法，将IP地址分为 公有IP 和 私有IP，每个个人所分配到的 IP 都是 私有IP 地址，每个 公有IP 下面会存在很多 私有IP， 如果我们想要访问网络，我们需要将访问的请求发给公有IP，在真正的网络上，你的请求使用的是公有IP，当然，如果想要真正找到另一个网络下的私有IP，并与之相互通信的话，需要将 IP 地址 和 Mac 地址相结合使用，这就是另一个故事了。</p>
<h4 id="1-IP-地址分类"><a href="#1-IP-地址分类" class="headerlink" title="1.  IP 地址分类"></a>1.  IP 地址分类</h4><p>Internet 委员会定义了 5 种 IP地址类型以适用不同容量的网路，A ～ E 类；但我们日常生活中只会接触到 A、B、C 三类 IP 地址。</p>
<ul>
<li>A类地址保留给政府机构；</li>
<li>B类地址分配给中等规模的公司；</li>
<li>C类地址分配给任何需要的人；</li>
<li>D类用于组播；</li>
<li>E类用于实验等。</li>
</ul>
<p>以下为 5 类 IP 格式的具体格式。</p>
<p><img src="/2019/09/18/计算机网络/%E4%BA%94%E7%A7%8DIP%E6%A0%BC%E5%BC%8F.png" alt></p>
<p>除了上述用来标志五类网络的标志位，每个IP地址包括两个标示码（ID），即 <strong>网络ID</strong> 和 <strong>主机ID</strong>。</p>
<p>那为什么要分 <strong>网络ID</strong> 和 <strong>主机ID</strong> 呢？</p>
<p>不论是分类还是分ID 都是为了利用分块的思想，是的路由跟快捷的找到相对对应的目的地，否则一个交换交换机要记42亿的ID了。</p>
<h4 id="2-子网掩码"><a href="#2-子网掩码" class="headerlink" title="2. 子网掩码"></a>2. 子网掩码</h4><p>子网掩码是用来划分网段用的，可将 大段IP 划分成多个 小段IP，每段 IP 有自己的网络号和广播地址。也是用来解决IP地址匮乏这个问题的。</p>
<h2 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h2><p>参考：</p>
<p><a href="https://www.jianshu.com/p/dac7b8bdb682" target="_blank" rel="noopener">https://www.jianshu.com/p/dac7b8bdb682</a></p>
<p><a href="http://www.cnblogs.com/ldq2016/" target="_blank" rel="noopener">http://www.cnblogs.com/ldq2016/</a> </p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Wise-Ant</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="/2019/09/18/计算机网络/">/2019/09/18/计算机网络/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/09/18/计算机的视界/">计算机的视界</a>
            
            
            <a class="next" rel="next" href="/2019/09/17/C-错误集锦/">C++ 错误集锦</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Wise-Ant | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
